(ns dk.cst.dannet.web.client
  "The central namespace of the frontend app."
  (:require [clojure.string :as str]
            [rum.core :as rum]
            [reitit.frontend :as rf]
            [reitit.frontend.easy :as rfe :refer [href]]
            [reitit.frontend.history :as rfh]
            [taoensso.telemere :as t]
            [dk.cst.dannet.web.ui :as ui]
            [dk.cst.dannet.web.ui.error :as error :include-macros true]
            [dk.cst.dannet.web.ui.page :as page]
            [dk.cst.dannet.shared :as shared])
  (:import [goog Uri]))

;; The React root element.
(defonce root (atom nil))

(defonce location
  (atom {}))

(defonce visited
  (atom {:back    '()
         :forward '()}))

(def app
  (js/document.getElementById "app"))

(def fallback
  "Catastrophic error fallback for when page-shell itself fails."
  (page/error {:languages ["en"]}))

(defn- mount-page!
  "Mount page-component with error protection for catastrophic failures."
  [page-component]
  ;; Protects the React render phase. Errors during hiccup generation
  ;; (in the let binding before this call) are not caught, but those
  ;; are unlikely since it's just data manipulation.
  ;;
  ;; The @root state tracks mounting status:
  ;;   nil               → first load, attempt hydration
  ;;   :hydration-failed → hydration failed, fall back to fresh mount
  ;;   other             → normal re-mount to existing React root
  (error/try-static-render app
    (case @root
      nil
      (do
        ;; Set before hydrate so if it throws, @root reflects the failure.
        (reset! root :hydration-failed)
        (reset! root (rum/hydrate page-component app)))

      :hydration-failed
      (do
        (t/log! :warn "Hydration failed previously - mounting fresh React root")
        (reset! root (rum/mount page-component app)))

      (rum/mount page-component @root))
    fallback))

;; All paths prefixed with /dannet/ are matched, content generated by the SPA.
;; Other routes bypass the frontend routing entirely, e.g. /download/...
;; Please refer to /doc/web.md to see how routing is meant to work.
(def routes
  [["/dannet" :delegate-root]
   ["/dannet/{*path}" :delegate-path]])

;; TODO: also do this for back/forward button
(defn- update-scroll-opts
  [history opts]
  (conj
    (rest history)
    [(ffirst history) opts]))

(defn- update-scroll-state!
  "Scroll to the top of the page if `url` is not from back/forward button."
  [url]
  (let [{:keys [back forward] :as urls} @visited
        [back-url back-opts] (first (rest back))
        [forward-url forward-opts] (first forward)
        anchor-click?   (-> urls meta :anchor-click?)
        back-button?    (= url back-url)
        forward-button? (= url forward-url)
        content-element (js/document.getElementById "content")]
    (swap! visited vary-meta dissoc :anchor-click?)
    (if (or anchor-click? (not (or back-button? forward-button?)))
      (let [opts (clj->js {:top (.-scrollTop content-element)})]
        (.scroll content-element #js {:top 0})
        (swap! visited assoc
               :back (if (empty? back)
                       (list [url #js {:top 0}])
                       (conj (update-scroll-opts back opts)
                             [url #js {:top 0}]))
               :forward '()))
      (cond
        back-button?
        (do
          (.scroll content-element back-opts)
          (swap! visited assoc
                 :back (rest back)
                 :forward (cons (first back) forward)))

        forward-button?
        (do
          (.scroll content-element forward-opts)
          (swap! visited assoc
                 :back (conj back (first forward))
                 :forward (rest forward)))))))

(defn- ignore-anchor-click?
  "Adds a side-effect to any intercepted anchor clicks in reitit making sure
  that the scroll state always resets when intentionally clicking a link.

  Works in conjunction with 'update-scroll-state!' defined above."
  [router e el uri]
  (when (and (rfh/ignore-anchor-click? router e el uri)
             ;; don't include downloads in client routing
             (not (re-find #"format=" (.getQuery uri))))
    (swap! visited vary-meta assoc :anchor-click? true)
    true))

(defn on-navigate
  [{:keys [path query-params] :as m}]
  ;; Abort in-flight fetches from previous pages to prevent race conditions
  ;; that cause queued pages to load unexpectedly in quick succession.
  (shared/abort-stale-fetches)

  ;; Record the target path. Callbacks later compare their closed-over path
  ;; against (:path @location) to detect if they've become stale.
  (swap! location assoc :path path)

  ;; Fetch the page data.
  (.then (shared/api path {:query-params query-params})
         #(do
            (shared/clear-current-fetch path)

            ;; Check staleness. If user clicked multiple links quickly,
            ;; this callback's `path` won't match the current target from step 2.
            (when (= path (:path @location))

              ;; We cannot intercept 30x redirects from JS, so the server sends
              ;; redirect info in a custom header instead.
              (if-let [redirect-path (shared/x-header (:headers %) :redirect)]
                ;; Further distinguish between internal and external redirects.
                (if (str/starts-with? redirect-path "/")
                  (let [replace? (= "T" (shared/x-header (:headers %) :replace))]
                    (shared/navigate-to redirect-path replace?))
                  (js/window.location.replace redirect-path))

                ;; The normal (i.e. non-redirect) navigation flow follows below.
                (let [{:keys [scroll]} @shared/post-navigate
                      headers        (:headers %)
                      page           (shared/x-header headers :page)
                      body           (not-empty (:body %))
                      page-component (ui/page-shell page body)
                      page-title     (shared/x-header headers :title)
                      has-deferred   (shared/x-header headers :has-deferred)]
                  (set! js/document.title page-title)
                  (reset! location {:path    path
                                    :headers headers
                                    :data    body})
                  ;; Preserve scroll position for back/forward, but reset to top
                  ;; for new navigations - except when clicking radial diagram
                  ;; labels, where scrolling away is disorienting.
                  (when-not (and (= scroll :diagram)
                                 (not (:full-screen @shared/state)))
                    (when-let [url (shared/response->url %)]
                      (update-scroll-state! url)))

                  ;; Ensure that the search overlay closes when clicking 'back'.
                  (js/document.activeElement.blur)

                  ;; The initial render of the new page occurs here.
                  (mount-page! page-component)

                  ;; Mark hydration complete so subsequent renders can show
                  ;; client-only elements like loading indicators.
                  (when-not ui/*hydrated*
                    (set! ui/*hydrated* true))

                  ;; Large Synset entities have truncated semantic relations on
                  ;; initial load. Fetch the remainder and re-render when ready.
                  ;; TODO: this causes word clouds to re-render every time.
                  ;;       Investigate whether we can skip re-mount.
                  (when has-deferred
                    (-> (shared/api path {:query-params (assoc query-params
                                                          :deferred true)})
                        (.then (fn [deferred-response]
                                 (shared/clear-current-fetch path)
                                 ;; The user may have navigated away while
                                 ;; this deferred request was in flight. If so,
                                 ;; @location now reflects a different page an
                                 ;; we must NOT merge stale data or remount,
                                 ;; as doing so would clobber the current page
                                 ;; with data from the previous one.
                                 (if (= path (:path @location))
                                   (when-let [deferred-body (:body deferred-response)]
                                     (let [merged-body   (update body :entity
                                                                 shared/merge-deferred-entity
                                                                 (:entity deferred-body))
                                           new-component (ui/page-shell page merged-body)]
                                       (reset! location {:path    path
                                                         :headers headers
                                                         :data    merged-body})
                                       (mount-page! new-component)))
                                   (t/log! {:level :warn
                                            :data  {:expected-path path
                                                    :current-path  (:path @location)}}
                                           "Discarded stale deferred response"))))
                        (.catch (fn [err]
                                  (t/log! {:level :warn
                                           :error err
                                           :data  {:path path}}
                                          "Deferred fetch failed")))))

                  (reset! shared/post-navigate nil)))))))


(defn set-up-navigation!
  []
  (rfe/start! (rf/router routes)
              on-navigate
              {:use-fragment         false
               :ignore-anchor-click? ignore-anchor-click?}))

(defn ^:dev/after-load render
  []
  (let [{:keys [data headers]} @location
        page-component (ui/page-shell (shared/x-header headers :page) data)]
    (set-up-navigation!)                                    ; keep up-to-date
    (mount-page! page-component)))

(defn init!
  "The entry point of the frontend app."
  []
  (let [entry-url (str js/window.location.pathname js/window.location.search)]
    (.then (shared/api entry-url)
           #(let [data           (:body %)
                  page           (shared/x-header (:headers %) :page)
                  page-component (ui/page-shell page data)]
              (shared/clear-current-fetch entry-url)
              (mount-page! page-component)
              (set-up-navigation!)))))
